-- 1. Создайте таблицу movies с полями movies_type, director, year_of_issue, length_in_minutes, rate.

create table de.movies_type (
	id serial primary key,
	title varchar(50) not null 
	);

alter table de.movies_type alter column id drop default;
drop sequence de.movies_type_id_seq;

insert into de.movies_type (id, title) values 
	(1, 'action'),
	(2, 'blockbuster'),
	(3, 'musical'),
	(4,' western'),
	(5, 'fantasy');

select * from de.movies_type mt ;

	
create table if not exists de.movies (
	id int generated by default as identity primary key, 
	movies_type_id int not null ,
	director varchar(50) not null,
	year_of_issue varchar(4) not  null,
	length_in_minutes smallint not null,
	rate int2 not null,
	foreign key (movies_type_id) references de.movies_type (id) on delete restrict
	);

alter table de.movies alter column year_of_issue type smallint using (year_of_issue::smallint);

select * from information_schema.columns
	where table_schema = 'de' and table_name = 'movies';

select * from information_schema.tables where table_schema = 'de' and table_name like 'movies%';

/*
 * 2. Сделайте таблицы для горизонтального партицирования по году выпуска 
 * (до 1990, 1990 -2000, 2000- 2010, 2010-2020, после 2020).
 */

drop table de.movies_year_more_2020;

create table de.movies_year_le_1990 (check (year_of_issue <= 1990)) inherits (de.movies);
create table de.movies_year_le_2000 (check (year_of_issue > 1990 and year_of_issue <= 2000)) inherits (de.movies);
create table de.movies_year_le_2010 (check (year_of_issue > 2000 and year_of_issue <= 2010)) inherits (de.movies);
create table de.movies_year_le_2020 (check (year_of_issue > 2010 and year_of_issue <= 2020)) inherits (de.movies);
create table de.movies_year_gt_2020 (check (year_of_issue > 2020)) inherits (de.movies);

select * from information_schema.columns
	where table_schema = 'de' and table_name = 'movies_year_le_1990';

/*
 * 3. Сделайте таблицы для горизонтального партицирования по длине фильма 
 * (до 40 минута, от 40 до 90 минут, от 90 до 130 минут, более 130 минут)
 */


--drop table de.movies_rate_le_10;

create table de.movies_min_le_40 (check (length_in_minutes <=40)) inherits (de.movies);
create table de.movies_min_le_90 (check (length_in_minutes <=90  and length_in_minutes > 40)) inherits (de.movies);
create table de.movies_min_le_130 (check (length_in_minutes <=130  and length_in_minutes > 90)) inherits (de.movies);
create table de.movies_min_gt_130 (check (length_in_minutes >130)) inherits (de.movies);

/*
 * 4. Сделайте таблицы для горизонтального партицирования по рейтингу фильма (ниже 5, от 5 до 8, от 8до 10).
 */

create table de.movies_rate_le_5  (check (rate <5)) inherits (de.movies);
create table de.movies_rate_le_8  (check (rate <8 and rate >= 5)) inherits (de.movies);
create table de.movies_rate_le_10 (check (rate <= 10 and rate >=8)) inherits (de.movies);
-- create table de.movies_rate_gt_10 (check (rate >=10)) inherits (de.movies);

/*
 * 5. Создайте правила добавления данных для каждой таблицы.
 * */

create rule movies_year_le_1990 as on insert to de.movies where (year_of_issue <= 1990) do instead insert into de.movies_year_le_1990 values (new.*);
create rule movies_year_le_2000 as on insert to de.movies where (year_of_issue > 1990 and year_of_issue <= 2000) do instead insert into de.movies_year_le_2000 values (new.*);
create rule movies_year_le_2010 as on insert to de.movies where (year_of_issue > 2000 and year_of_issue <= 2010) do instead insert into de.movies_year_le_2010 values (new.*);
create rule movies_year_le_2020 as on insert to de.movies where (year_of_issue > 2010 and year_of_issue <= 2020) do instead insert into de.movies_year_le_2020 values (new.*);
create rule movies_year_gt_2020 as on insert to de.movies where (year_of_issue > 2020) do instead insert into de.movies_year_gt_2020 values (new.*);


create rule movies_min_le_40  as on insert to de.movies where (length_in_minutes <=40) do instead insert into  de.movies_min_le_40 values (new.*) ;

create rule movies_min_le_90  as on insert to de.movies where (length_in_minutes <=90   and length_in_minutes > 40)  do instead insert into de.movies_min_le_90 values (new.*) ;
create rule movies_min_le_130 as on insert to de.movies where (length_in_minutes <=130  and length_in_minutes > 90) do instead insert into de.movies_min_le_130 values (new.*);
create rule movies_min_gt_130 as on insert to de.movies where (length_in_minutes > 130) do instead insert into de.movies_min_gt_130 values (new.*);

create rule movies_rate_le_5  as on insert to de.movies where (rate < 5) do instead insert into de.movies_rate_le_5 values (new.*);
create rule movies_rate_le_8  as on insert to de.movies where (rate <8 and rate >= 5) do instead insert into de.movies_rate_le_8 values (new.*);
create rule movies_rate_le_10 as on insert to de.movies where (rate <=10 and rate >=8) do instead insert into de.movies_rate_le_10 values (new.*);

/*
 * 6. Добавьте фильмы так, чтобы в каждой таблице было не менее 3 фильмов.
 */

INSERT INTO de.movies (movies_type_id, director, year_of_issue, length_in_minutes,rate)
VALUES
  (3,'Constance Stone',2017,25,13),
  (1,'Allistair Warner',2022,26,6),
  (4,'Chester Dotson',2018,35,7),

  (2,'Nicholas Richard',2010,79,5),
  (1,'Nevada Dejesus',2004,49,9),
  (3,'Hermione Phelps',2001,78,7),
  (5,'Evan Wong',1984,69,5),
  --7
  (2,'Marsden Smith',1984,119,8),
  (3,'Victor Mcleod',1994,117,10),
  (5,'Dieter Battle',2010,100,3),
--10
  (2,'Rowan Armstrong',1990,135,3),
  (2,'Mari Puckett',2020,144,13),
  (1,'Alisa Kelley',2003,149,7),
--13
  (2,'Freya Stanley',2011,26,9),
  (4,'Audra Guzman',1992,22,5),
  (3,'Dale Hanson',2024,33,6),
  (3,'Ignatius Mccormick',1997,21,3),
  (3,'Bell Kennedy',1980,25, 3),
  (2,'Jared Henry',2020,39,4),
  (3,'Bell Kennedy',1980,25,7),
  (1,'Yvonne Freeman',1982,23,6),
  (5,'Wing Poole',2002,21,8),
  (3,'Kasper Rollins',2009,31,7),
  (5,'Buckminster Carver',2005,31,8),
  (2,'Fay Barron',1986,30,14),
  (4,'Porter Walters',1987,29,2),
  (2,'Cairo Heath',2024,35,10),
  (4,'Aspen Conrad',2018,29,8),
  (5,'Venus House',1998,34,15),
  (5,'Aileen Mullins',1980,23,1),
  (2,'Donovan Romero',1983,125,6),
  (3,'Robert Fisher',1994,124,2),
  (3,'Camden Oneal',2000,120,2),
  (4,'Pamela Merrill',2018,98,8),
  (4,'Len Peck',1984,91,2),
  (1,'Asher Gordon',2013,70,3),
  (3,'Winter Walsh',2004,37,5),
  (5,'Constance Kirk',2019,138,6),
  (3,'Fatima Yates',1996,82,7),
  (2,'Murphy Sparks',2019,85,4),
  (5,'Constance Kirk',2019,138,6),
  (2,'Yael Burch',1983,82,14),
  (3,'Fatima Yates',1996,82,7),
  (3,'Daniel Battle',1999,118,10),
  (2,'Murphy Sparks',2019,85,4),
  (2,'Hannah Murphy',2014,70,12),
  (2,'Stone Galloway',1992,146,15),
  (3,'Daniel Battle',1999,118,10),
  (2,'Hannah Murphy',2014,70,12),
  (2,'Stone Galloway',1992,146,15),
  (2,'Ryan Barr',2000,21,11),
  (2,'Yael Burch',1983,82,14);
--52
/*
 *  7. Добавьте пару фильмов с рейтингом выше 10.
 */
 
INSERT INTO de.movies (movies_type_id, director, year_of_issue, length_in_minutes,rate)
VALUES
  (2,'Tana Battle',2021,37,14),
  (2,'Oliver Williamson',1980,33,11),
 
/*8. Сделайте выбор из всех таблиц, в том числе из основной.
 * 
 */

-- delete  from de.movies ;

select * from de.movies ;
 
select * from de.movies_year_le_1990;
select * from de.movies_year_le_2000;
select * from de.movies_year_le_2010;
select * from de.movies_year_le_2020;
select * from de.movies_year_gt_2020;

select * from de.movies_min_gt_130;
select * from  de.movies_min_le_130;
select * from  de.movies_min_le_90;
select * from  de.movies_min_le_40;

select * from de.movies_rate_le_10;
select * from de.movies_rate_le_5;
select * from de.movies_rate_le_8;

/*9. Сделайте выбор только из основной таблицы.
 * 
 */
select * from only de.movies ;


select * from information_schema.tables where table_schema = 'de' and table_name like 'movies%';

/*10 Выше  приведен очень странный пример партицирования. Т.к. данные добавляются одновременно в несколько таблиц, что не очень соответствует тому, что написано в литературе по 
 * партицированию.
 * Условия для разделения данных не должны пересекаться.
 * Наличие пересекающихся условий приводит к тому, что данные в основной таблице начинают дублироваться, никакого выигрыша в производительности нет, т.к. запрос сканирует 
 * все партиции.
 * было добавлено сначала 52 строки среди которых были записи с рейтингом 10 и потом еще 2 с рейтингом 10 которые не попали в отдельную таблицу.
 * В общей таблице запрос выбирает 149 строк. что конечно же недопустимо
 * Идея партиционирования дискредитируется.
 * Нашел описание многоуновневого партицирования только в одном месте.
--  https://studfile.net/preview/9546965/page:11/ Композитное секционирование.
 * если нужно многоуровневое партицирование. то партицируется партиция предыдущего уровня по аналоги с основной таблицей.
 * Ниже пример двухуровневого партицирования без пересечения.
 * Данные будут распределяться только в таблицы 
 */

create table if not exists de.mv (
	id int generated by default as identity primary key, 
	movies_type_id int not null ,
	director varchar(50) not null,
	year_of_issue smallint not  null,
	length_in_minutes smallint not null,
	rate int2 not null,
	foreign key (movies_type_id) references de.movies_type (id) on delete restrict
	);


create table de.mv_year_le_1990 (check (year_of_issue <= 1990)) inherits (de.mv);
create table de.mv_year_le_2020 (check (year_of_issue > 1990 and year_of_issue <= 2020)) inherits (de.mv);
create table de.mv_year_gt_2020 (check (year_of_issue > 2020)) inherits (de.mv);

create rule mv_year_le_1990 as on insert to de.mv where (year_of_issue <= 1990) do instead insert into de.mv_year_le_1990 values (new.*);
create rule mv_year_le_2020 as on insert to de.mv where (year_of_issue > 1990 and year_of_issue <= 2020) do instead insert into de.mv_year_le_2020 values (new.*);
create rule mv_year_gt_2020 as on insert to de.mv where (year_of_issue > 2020) do instead insert into de.mv_year_gt_2020 values (new.*);

create table de.mv_year_le_1990_min_le_40  (check (year_of_issue <= 1990 and length_in_minutes <=40)) inherits (de.mv_year_le_1990);
create table de.mv_year_le_1990_min_le_90  (check (year_of_issue <= 1990 and length_in_minutes <=90  and length_in_minutes > 40 )) inherits (de.mv_year_le_1990);
create table de.mv_year_le_1990_min_le_130 (check (year_of_issue <= 1990 and length_in_minutes <=130 and length_in_minutes > 90 )) inherits (de.mv_year_le_1990);
create table de.mv_year_le_1990_min_gt_130 (check (year_of_issue <= 1990 and length_in_minutes >130)) inherits (de.mv_year_le_1990);

create rule mv_year_le_1990_min_le_40  as on insert to de.mv_year_le_1990 where (year_of_issue <= 1990 and length_in_minutes <= 40)
	do instead insert into de.mv_year_le_1990_min_le_40 values (new.*) ;
create rule mv_year_le_1990_min_le_90  as on insert to de.mv_year_le_1990 where (year_of_issue <= 1990 and length_in_minutes <=90   and length_in_minutes > 40)
	do instead insert into de.mv_year_le_1990_min_le_90 values (new.*) ;
create rule mv_year_le_1990_min_le_130 as on insert to de.mv_year_le_1990 where (year_of_issue <= 1990 and length_in_minutes <=130  and length_in_minutes > 90)
	do instead insert into de.mv_year_le_1990_min_le_130 values (new.*);
create rule mv_year_le_1990_min_gt_130 as on insert to de.mv_year_le_1990 where (year_of_issue <= 1990 and length_in_minutes > 130) 
    do instead insert into de.mv_year_le_1990_min_gt_130 values (new.*);

create table de.mv_year_le_2020_min_le_40  (check (year_of_issue > 1990 and year_of_issue <= 2020 and length_in_minutes <=40)) inherits (de.mv_year_le_2020);
create table de.mv_year_le_2020_min_le_90  (check (year_of_issue > 1990 and year_of_issue <= 2020 and length_in_minutes <=90  and length_in_minutes > 40 )) inherits (de.mv_year_le_2020);
create table de.mv_year_le_2020_min_le_130 (check (year_of_issue > 1990 and year_of_issue <= 2020 and length_in_minutes <=130 and length_in_minutes > 90 )) inherits (de.mv_year_le_2020);
create table de.mv_year_le_2020_min_gt_130 (check (year_of_issue > 1990 and year_of_issue <= 2020 and length_in_minutes >130)) inherits (de.mv_year_le_2020);

create rule mv_year_le_2020_min_le_40  as on insert to de.mv_year_le_2020 where (year_of_issue > 1990 and year_of_issue <= 2020 and length_in_minutes <= 40)
	do instead insert into de.mv_year_le_2020_min_le_40 values (new.*) ;
create rule mv_year_le_2020_min_le_90  as on insert to de.mv_year_le_2020 where (year_of_issue > 1990 and year_of_issue <= 2020 and length_in_minutes <=90   and length_in_minutes > 40)
	do instead insert into de.mv_year_le_2020_min_le_90 values (new.*) ;
create rule mv_year_le_2020_min_le_130 as on insert to de.mv_year_le_2020 where (year_of_issue > 1990 and year_of_issue <= 2020 and length_in_minutes <=130  and length_in_minutes > 90)
	do instead insert into de.mv_year_le_2020_min_le_130 values (new.*);
create rule mv_year_le_2020_min_gt_130 as on insert to de.mv_year_le_2020 where (year_of_issue > 1990 and year_of_issue <= 2020 and length_in_minutes > 130) 
    do instead insert into de.mv_year_le_2020_min_gt_130 values (new.*);


create table de.mv_year_gt_2020_min_le_40  (check (year_of_issue > 2020 and length_in_minutes <=40)) inherits (de.mv_year_gt_2020);
create table de.mv_year_gt_2020_min_le_90  (check (year_of_issue > 2020 and length_in_minutes <=90  and length_in_minutes > 40 )) inherits (de.mv_year_gt_2020);
create table de.mv_year_gt_2020_min_le_130 (check (year_of_issue > 2020 and length_in_minutes <=130 and length_in_minutes > 90 )) inherits (de.mv_year_gt_2020);
create table de.mv_year_gt_2020_min_gt_130 (check (year_of_issue > 2020 and length_in_minutes >130)) inherits (de.mv_year_gt_2020);

create rule mv_year_gt_2020_min_le_40  as on insert to de.mv_year_gt_2020 where (year_of_issue > 2020 and length_in_minutes <= 40)
	do instead insert into de.mv_year_gt_2020_min_le_40 values (new.*) ;
create rule mv_year_gt_2020_min_le_90  as on insert to de.mv_year_gt_2020 where (year_of_issue > 2020 and length_in_minutes <=90   and length_in_minutes > 40)
	do instead insert into de.mv_year_gt_2020_min_le_90 values (new.*) ;
create rule mv_year_gt_2020_min_le_130 as on insert to de.mv_year_gt_2020 where (year_of_issue > 2020 and length_in_minutes <=130  and length_in_minutes > 90)
	do instead insert into de.mv_year_gt_2020_min_le_130 values (new.*);
create rule mv_year_gt_2020_min_gt_130 as on insert to de.mv_year_gt_2020 where (year_of_issue > 2020 and length_in_minutes > 130) 
    do instead insert into de.mv_year_gt_2020_min_gt_130 values (new.*);


INSERT INTO de.mv (movies_type_id, director, year_of_issue, length_in_minutes,rate)
VALUES
  (3,'Constance Stone',2017,25,13),
  (1,'Allistair Warner',2022,26,6),
  (4,'Chester Dotson',2018,35,7),
  (2,'Nicholas Richard',2010,79,5),
  (1,'Nevada Dejesus',2004,49,9),
  (3,'Hermione Phelps',2001,78,7),
  (5,'Evan Wong',1984,69,5),
  (2,'Marsden Smith',1984,119,8),
  (3,'Victor Mcleod',1994,117,10),
  (5,'Dieter Battle',2010,100,3),
  (2,'Rowan Armstrong',1990,135,3),
  (2,'Mari Puckett',2020,144,13),
  (1,'Alisa Kelley',2003,149,7),
  (2,'Freya Stanley',2011,26,9),
  (4,'Audra Guzman',1992,22,5),
  (3,'Dale Hanson',2024,33,6),
  (3,'Ignatius Mccormick',1997,21,3),
  (3,'Bell Kennedy',1980,25, 3),
  (2,'Jared Henry',2020,39,4),
  (3,'Bell Kennedy',1980,25,7),
  (1,'Yvonne Freeman',1982,23,6),
  (5,'Wing Poole',2002,21,8),
  (3,'Kasper Rollins',2009,31,7),
  (5,'Buckminster Carver',2005,31,8),
  (2,'Fay Barron',1986,30,14),
  (4,'Porter Walters',1987,29,2),
  (2,'Cairo Heath',2024,35,10),
  (4,'Aspen Conrad',2018,29,8),
  (5,'Venus House',1998,34,15),
  (5,'Aileen Mullins',1980,23,1),
  (2,'Donovan Romero',1983,125,6),
  (3,'Robert Fisher',1994,124,2),
  (3,'Camden Oneal',2000,120,2),
  (4,'Pamela Merrill',2018,98,8),
  (4,'Len Peck',1984,91,2),
  (1,'Asher Gordon',2013,70,3),
  (3,'Winter Walsh',2004,37,5),
  (5,'Constance Kirk',2019,138,6),
  (3,'Fatima Yates',1996,82,7),
  (2,'Murphy Sparks',2019,85,4),
  (5,'Constance Kirk',2019,138,6),
  (2,'Yael Burch',1983,82,14),
  (3,'Fatima Yates',1996,82,7),
  (3,'Daniel Battle',1999,118,10),
  (2,'Murphy Sparks',2019,85,4),
  (2,'Hannah Murphy',2014,70,12),
  (2,'Stone Galloway',1992,146,15),
  (3,'Daniel Battle',1999,118,10),
  (2,'Hannah Murphy',2014,70,12),
  (2,'Stone Galloway',1992,146,15),
  (2,'Ryan Barr',2000,21,11),
  (2,'Yael Burch',1983,82,14);

 -- добавлено 52 строки
 
 select * from de.mv;

-- запрос возвращет 52 строки. все правильно.
-- промежуточные партиции данных не содержат.

select * from only de.mv_year_le_1990; -- 0 записей
select * from only de.mv_year_le_2020; -- 0 записей
select * from only de.mv_year_gt_2020; -- 0 записей


   
